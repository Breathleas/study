1.

2. 随着业务迭代，性能问题逐渐显现，一个一个解决问题（效率低、效果不明显），将bug归类，解决同一系列的bug，做到一劳永逸

4. 在性能优化过程中要关心哪些问题？用户关心什么问题，致命问题：崩溃、卡死、白屏；另一类型问题：安装包大小、启动、耗时、内存、耗电、流量。

5. 使用lint工具对unused resource进行扫描，

6. 每个Android应用在启动的时候都会创建一个UI线程，为了保证UI的流畅性，会将一些耗时操作放在子线程中，有些轻量的异步任务就直接new Thread()，但是线程并不是免费的，每个线程会占用一定的内存空间；太多的线程会相互竞争CPU资源，而每次切换上下文都需要刷新寄存器和计数器，至少需要几十纳秒的时间，这样就导致系统把大量时间都浪费在切换线程上下文过程中（当CPU繁忙的时候，线程调度会对执行效率有非常大的影响）。

针对上述问题，为控制线程的数量，我们封装了统一的线程管理类，对于固定的任务使用固定的线程（如数据库操作使用数据库线程、网络操作使用网络线程等），对于其它的异步操作，统一使用线程池，

在输入法中存在大量的IPC操作，每次输入都有1-2次IPC

在线程优化中，我们希望主线程和各个子线程的时间片都是满载的（每个线程都开足马力向前跑，而不是做接力棒），具体来说，线程的优化有两个方面：一方面是控制线程的数量、另一方面是控制线程之间的锁，避免存在高优先级的线程空等低优先级的线程，（例如主线程等待某个后台线程的锁），

9. 随着业务的迭代，各种配置项（如：第几次调起键盘、第几次进入主题页、云控）等逻辑越来越多，sp文件越来越大，sp原生API的限制：
1.IO瓶颈：读取数据到内存（sp文件没有被加载到内存时，调用getSharedPreferences方法会初始化文件并读入内存）、写入数据到磁盘（执行Editor的commit方法会同步写入磁盘、执行apply方法会异步写入磁盘）
2.锁性能差：SP的get操作，会锁定SharedPreferences对象，互斥其他操作。put操作会锁定Editor对象，写入磁盘更会锁定一个写入锁。由于锁的缘故，SP操作并发时，耗时会徒增

10. mmap和普通文件读写有什么区别？为什么mmap效率更高
普通文件读操作：需要将文件从硬盘拷贝到内核空间一个缓存区，然后再将这些数据拷贝到用户空间，需要完成两次数据拷贝

mmap的实现：1. 在虚拟地址空间为映射创建虚拟映射区域 2. 内核空间系统调用mmap函数，实现文件物理地址和进程虚拟地址的一一映射 3. 进程发起对这片空间的访问，在地址映射表中无法找到与ptr相对应的物理地址，发生一个缺页终中断，缺页中断的响应函数会实现文件到物理内存（主存）的拷贝

其中flags参数使用了MAP_SHARED，可以将映射出来的内存做的任何修改会通过系统反馈回文件中，也就是只需管理好这块内存，文件的读写交由系统完成，避免了奔溃导致数据丢失的情况。

11. 之前业务逻辑都是揉在latinIME中，通过接口分离原则剥离输入主逻辑和各个业务模块，使各模块各司其职，符合单一指责原则，同时也有利于代码维护，主输入逻辑优先执行，保证键盘调起的速度，其余业务模块可以在主线程空闲时执行

12. 网络管理、线程管理、本地配置项管理等作为工程基础模块统一管理各业务资源；中间层：上报、云控、预测模块为支撑业务的独立模块；最上层为业务模块

13. ANR和用户留存对照图，ANR和用户留存的关系整体呈负相关，

14. Memory Monitor实时更新出应用程序所占用的内存的情况
Allocation Tracker(所有已分配的内存、所有已创建的对象、以及这些对象的数量) 的三个缺点
获取的信息过于分散，中间夹杂着不少其他的信息
无法做到自动化分析，每次都需要开发者手工开始 / 结束

Heap Viewer可以实时展示应用程序在运行过程中已分配的对象的数量、大小、类型
在 Allocation Tracking 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 dump 出来之前，经常会把手机完全卡死，

15. instrument：获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。
sample：有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。


 Traceview  利用 Android Runtime 函数调用的 event事件，将函数运行的耗时和调用关系写入 trace 文件中
Uber 开源的Nanoscope  直接修改 Android 虚拟机源码，在ArtMethod执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。
缺点：需要自己刷ROM，只支持Nexus 6P
     默认只采用主线程采集，其它线程需要代码手动设置

systrace 工具只能监控特定系统调用的耗时情况，所以它是属于 sample 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。

Simpleperf 所有的 Native 代码的耗时

如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择Traceview 或者插桩版本的 systrace。
