# 崩溃优化
完整的 Native 崩溃从捕获到解析要经历的流程：
1. 编译端：编译 C/C++ 代码时，需要将带符号信息的文件保留下来。
2. 客户端：捕获到崩溃时候，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。
3. 服务端：读取客户端上报的日志文件，寻找适合的符号文件，生成可读的 C/C++ 调用栈。

如何发现应用中的ANR:
1. 使用 FileObserver 监听 /data/anr/traces.txt 的变化
2. 监控消息队列的运行时间

应用有哪些退出的情形：
1. 主动自杀。Process.killProcess()、exit() 等。
2. 崩溃。出现了 Java 或 Native 崩溃。
3. 系统重启；系统出现异常、断电、用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记录的值更小。
4. 被系统杀死。被 low memory killer 杀掉、从系统的任务管理器中划掉等。
5. ANR

资源泄漏：
1. 文件句柄 fd。
2. 线程数
3. JNI（DumpReferenceTables 统计 JNI 的引用表）

#### 其它
系统内存状态，可以直接读取文件 /proc/meminfo。
虚拟内存可以通过 /proc/self/status 得到，通过 /proc/self/maps 文件可以得到具体的分布情况
文件句柄的限制可以通过 /proc/self/limits 获得

#### TODO：
Chromium 的Breakpad
Hardcoder框架
Xposed
应用使用内存。包括 Java 内存、RSS（Resident Set Size）、PSS（Proportional Set Size），
我们可以得出应用本身内存的占用大小和分布。PSS 和 RSS 通过 /proc/self/smap 计算，可以进
一步得到例如 apk、dex、so 等更加详细的分类统计。
64 位的 CPU，虚拟内存一般在 3～4GB 之间
DumpReferenceTables 统计 JNI 的引用表
GDB工具
hook liblog.so  hook libart.so

# 内存优化
内存优化
1. 设备分级
2. Bitmap 优化
   方法一，统一图片库
   方法二，统一监控
3. 内存泄漏

内存监控
1. 采集方式
2. 计算指标
   内存异常率：内存 UV 异常率 = PSS 超过 400MB 的 UV / 采集 UV
   触顶律：内存 UV 触顶率 = Java 堆占用超过最大堆限制的 85% 的 UV / 采集 UV
3. GC监控

#### 其它
1. ART 虚拟机在内存管理跟回收策略上都做大量优化，内存分配和 GC 效率相比提升了 5～10倍
2. 如果想具体测试 GC 的性能，例如暂停挂起时间、总耗时、GC 吞吐量，我们可以通过发送SIGQUIT 信号获得 ANR 日志
adb shell kill -S QUIT PID
adb pull /data/anr/traces.txt

#### TODO：
以 LPDDR4 为例，带宽 = 时钟频率 × 内存总线位数 ÷ 8，
NativeAllocationRegistry
Allocation Tacker
首先 Google 之前将 Valgrind 弃用，建议我们使用 Chromium 的AddressSanitize 。
Native 内存的问题，有两种方法，分别是Malloc 调试和Malloc 钩子。
美团有一个 Android 内存泄露自动化链路分析组件Probe
针对无法重编 so 的情况，使用了 PLT Hook 拦截库的内存分配函数，其中 PLT Hook 是 NativeHook 的一种方案，

# 卡顿优化
基础知识：
1. CPU性能
   获取CPU信息：
   // 获取 CPU 核心数
   cat /sys/devices/system/cpu/possible
   // 获取某个 CPU 的频率
   cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq
2. 卡顿问题分析指标
   CPU 的使用率：/proc/[pid]/stat
      top 命令可以帮助我们查看哪个进程是 CPU 的消耗大户；
      vmstat 命令可以实时动态监视操作系统的虚拟内存和CPU 活动；
      strace 命令可以跟踪某个进程中所有的系统调用。
   CPU 饱和度：线程排队等待 CPU 的情况，也就是 CPU 的负载情况。
      使用vmstat命令或者/proc/[pid]/schedstat文件来查看 CPU 上下文切换次数（nr_involuntary_switches被动切换的次数）
      通过 uptime 命令可以检查 CPU 在 1 分钟、5 分钟和 15 分钟内的平均负载

Android 卡顿排查工具
1. Traceview（属于 instrument 类型）
2. Nanoscope（为基本没有性能损耗的 instrument 工具，它非常适合做启动耗时的自动化分析）
3. systrace（systrace 跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。属于 sample 类型）
4. Simpleperf（属于 sample 类型）

卡顿监控：
1. 基于消息队列实现，通过替换 Looper 的 Printer 实现
2. 插桩（matrix）
3. Profilo（Facebook 开源了一个叫Profilo的库）

其它监控
1. 帧率
2. 生命周期监控
3. 线程监控

系统 ANR 的生成机制
1. 第一步：当监控到主线程卡顿时，主动向系统发送 SIGQUIT 信号。
2. 第二步：等待 /data/anr/traces.txt 文件生成。
3. 第三步：文件生成以后进行上报

获得所有线程堆栈的方法：
1. 通过libart.so、dlsym调用ThreadList::ForEach方法，拿到所有的 Native 线程对象。
2. 遍历线程对象列表，调用Thread::DumpState方法。

#### 其它
Android Vitals 将连续丢帧超过 700 毫秒定义为冻帧，也就是连续丢帧 42 帧以上。

#### TODO：
systrace 利用了 Linux 的ftrace调试工具
Simpleperf性能分析工具
OAT 文件。
其中 Simpleperf 的反混淆比较难实现，因为在函数聚合后会抛弃参数，无法直接对生成的 HTML 文件做处理。
WxPerformanceTool
Inline Hook 技术
Profilo 通过 PLT Hook 拦截了写入操作
Profilo 的实现非常精妙，它实现类似 Native 崩溃捕捉的方式快速获取 Java 堆栈，通过间隔发送SIGPROF 信号
Android Vitals 是 Google Play 官方的性能监控服务
通过 got hook 线程的 nativeCreate() 函数
线程间的死锁和热锁

# 启动优化

#### 其它
#### TODO：
# IO优化

#### 其它
#### TODO：
# 存储优化
