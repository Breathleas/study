## wait()
线程会释放掉它所占有的“锁标志”，从而使线程所在对象中的其它synchronized数据可被别的线程使用
## notify()
## notifyAll
## sleep()
让线程休息指定的时间，时间一到就继续运行。
## join()
让指定的线程先执行完再执行其他线程，而且会阻塞主线程
线程A调用了线程B的join()方法时，表示只有当B执行完毕后，A线程才能继续执行
join()方法中传入参数，线程A调用了线程B的join(10)方法时，表示A线程会等待B线程执行10毫秒，10毫秒后A、B线程并行执行。
jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。
join方法必须在线程start方法调用之后调用才有意义

join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。
## yield()
让指定线程先礼让一下别的线程先执行。注：yield()只会礼让给相同优先级的或者是优先级更高的线程执行，yield()这个方法只是把线程的执行状态打回准备就绪状态，所以执行了该方法后，可能马上又开始运行，也可能等待很长时间

## 线程的状态
线程有四种状态
1.产生：线程对象已经产生，但尚未被启动。（如通过new产生了一个线程对象后没对它调用start()函数之前）
2.可执行：（如执行了一个线程对象的start()方法后，线程就处于可执行状态，但此时的线程不一定正在执行中）
3.死亡：一个线程正常结束，它便处于死亡状态。（如一个线程的run()函数执行完毕后线程就进入死亡状态）
4.停滞：当一个线程处于停滞状态时，系统排程器就会忽略它，不对它进行排程，当处于停滞状态的线程重新回到可执行状态时，它有可能重新执行。（如通过一个线程调用wait()函数后，线程就进入停滞状态）
